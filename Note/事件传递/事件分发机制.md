# 事件分发机制

>这次说下Android中的事件分发机制 从开始点击屏幕开始，就会产生从Activity开始到decorview一直到最里层的view一连串事件传递。每一层view或者viewgroup都会首先调用它的dispatchTouchEvent方法，然后判断是否就在当前一层消费掉事件

## view的事件分发

首先上一段伪代码，是在书上看到的，也是我觉得总结的最好的

```java
public boolean dispatchTouchEvent(MotionEvent event) {
    boolean isConsume = false;
    if (isViewGroup) {
        if (onInterceptTouchEvent(event)) {
            isConsume = onTouchEvent(event);
        } else {
            isConsume = child.dispatchTouchEvent(event);
        }
    } else {
        //isView
        isConsume = onTouchEvent(event);
    }
    return isConsume;
}
```

如果当前是viewgroup层级，就会判断 ***onInterceptTouchEvent*** 是否为true，如果为true，则代表事件要消费在这一层级，不再往下传递。接着便执行当前 ***viewgroup*** 的onTouchEvent方法。如果onInterceptTouchEvent为false，则代表事件继续传递到下一层级的 dispatchTouchEvent方法，接着一样的代码逻辑，一直到最里面一层的view。

ok，还没完哦，到最里面一层就会直接执行onTouchEvent方法，这时候，view有没有权利拒绝消费事件呢？ 按道理view作为最底层的，应该是没有发言权才对。但是呢，秉着公平公正原则，view也是可以拒绝的，可以在onTouchEvent方法返回false，表示他不想消费这个事件。那么这个事件又会怎么处理呢？见下面一段伪代码：

```java
public void handleTouchEvent(MotionEvent event) {
    if (!onTouchEvent(event)) {
        getParent.onTouchEvent(event);
    }
}
```

如果view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent又会被调用，如果父容器的onTouchEvent又返回false，则又交给上一级。一直到最上层，也就是Activity的onTouchEvent被调用。

**至此，消费流程完毕** 但是，*关于onTouch，onTouchEvent和onClick又是怎么样的调用关系呢？* 那就再来一段伪代码：

```java
public void consumeEvent(MotionEvent event) {
    if (setOnTouchListener) {
        onTouch();
        if (!onTouch()) {
            onTouchEvent(event);
        }
    } else {
        onTouchEvent(event);
    }

    if (setOnClickListener) {
        onClick();
    }
}
```

当某一层viewGroup的onInterceptTouchEvent被调用，则代表当前层级要消费事件。如果它的onTouchListener被设置了的话，则onTouch会被调用，如果onTouch的返回值返回true，则onTouchEvent不会被调用。如果返回false或者没有设置onTouchListener，则会继续调用onTouchEvent。而onClick方法则是设置了onClickListener则会被正常调用。

这里用一张流程图总结下：

![](事件分发机制.assets/171eea66ac7e8e8ctplv-t2oaga2asx-watermark.awebp)



## 源码分析

一个触摸事件，首先是传到Activity层级，然后传到根view，通过一层层的viewgroup最终到底最里面一层的view，我们来一层层解析

```java
	//Activity.java
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
    
     public void onUserInteraction() {
     }

```

这里可以看到，`onUserInteraction()` 方法是空的，主要是调用了 `getWindow().superDispatchTouchEvent(ev)` 方法，返回true，就代表事件消费了。返回false，就代表下层没人处理，那就直接到了activity的 `onTouchEvent()` 方法，这点跟之前的消费传递也是吻合的。

继续看看 `superDispatchTouchEvent()` 方法，然后就走到了PhoneWindow的superDispatchTouchEvent方法(PhoneWindow是Window的唯一实现类)，以及DecorView的superDispatchTouchEvent，看看代码：

```java
    //PhoneWindow.java
    private DecorView mDecor;
    @Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
    }
    
    //DecorView.java
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return super.dispatchTouchEvent(event);
    }
```

这里可以看到，依次经过了PhoneWindow到达了DecorView，DecorView是activity的根view，也是setcontentView所设置的view的父view，它是继承自FrameLayout。所以这里super.dispatchTouchEvent(event)方法，其实就是走到了viewGroup的`dispatchTouchEvent` 方法。



#### ViewGroup（dispatchTouchEvent）

```java
   @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (onFilterTouchEventForSecurity(ev)) {
            // Check for interception,表示是否拦截的字段
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
              //FLAG_DISALLOW_INTERCEPT标志是通过requestDisallowInterceptTouchEvent设置
                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }
          
          
          //mFirstTouchTarget赋值
             while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    } else {
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            continue;
                        }
                    }
                }          
        }
```





### 鼠标事件

1. `ACTION_HOVER_ENTER`：指针移入到窗口或者View区域，但没有按下。
2. `ACTION_HOVER_MOVE`：指针在窗口或者View区域移动，但没有按下。
3. `ACTION_HOVER_EXIT`：指针移出到窗口或者View区域，但没有按下。
4. `ACTION_SCROLL`： 滚轮滚动，可以触发水平滚动(AXIS_HSCROLL)或者垂直滚动(AXIS_VSCROLL)





参考：

[这次，我把Android事件分发机制翻了](https://juejin.cn/post/6844904150283583502)

[Android触摸滑动全解（四）——MotionEvent详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/1885f3ec49c0)
